---
title: "The Effectiveness of TIFs in Chicago"
format: 
  html:
    self-contained: true
    embed-resources: true
editor: visual
execute: 
  echo: true
  include: true
---

# The Effectiveness of Tax Increment Financing (TIFs) in Ameliorating Blight and Promoting Economic Development for The City of Chicago

## Introduction

#### What is Tax Increment Financing?

According to the webpage for the City of Chicago: <https://www.chicago.gov/city/en/depts/dcd/supp_info/tax_increment_financingprogram.html>

*"Tax Increment Financing is a special funding tool used by the City of Chicago to promote public and private investment across the city. Funds are used to build and repair roads and infrastructure, clean polluted land and put vacant properties back to productive use, usually in conjunction with private development projects. Funds are generated by growth in the Equalized Assessed Valuation (EAV) of properties within a designated district over a period of 23 years."*

**Purpose of TIFs:**

Tax Increment Financing is a special funding tool that is directed towards areas of diminished economic value and quality of life. Municipalities perform studies to determine if an area is eligble for a TIF if it is considered blighted or in danger of becoming blighted. If a TIF is determined as necessary a development project is created and a TIF budget is allocated to the region. TIFs have been a practice in Chicago since the 1970's. Usually, those who live outside of the TIF region pay more in Excessive Vacancies taxes that support the TIF budget. Much of the budget goes towards plan development, surveys, engineering, acquiring land, environmental clean up, demolition, infrastucture improvemnets, job training, building construction, consulting fees, etc. When a TIF ends, remaining money is then given back to the county.

**Controversy around TIFs:**

There are several reasons why many consider TIFs to be controversial. Many believe that the term "blighted" is applied too loosely ,such as in the case of extending TIF funding to wealthier areas. TIFs also are subject to scrutiny in light of the fact that their funds are kept separate from other municipal revenue. Many also criticize TIFs for allowing corporate eligibility.

**Success of TIFs**

The question of whether or not tax revenue increasing is a successful operation is often found to be ambiguous. In this project I will attempt to see if TIFs have generated economic development and reduced "blight".

*Information Source:* <https://www.youtube.com/watch?v=Zyp8PR9QzUQ>

**What is Blight?**

The city of Chicago as of 2022 has a few principle indicators of blight:

-   "**Dilapidation:** An advanced state of disrepair or neglect; critical defects in primary structural components, building systems and secondary structural components"

-   "**Obsolescence:** A building or improvement which is in the process of falling into disuse or has become ill suited for the original use"

-   "**Deterioration:** Physical deficiencies or disrepair in buildings or site improvements that are beyond normal maintenance; major defects in the doors, win- dows, porches, gutters and downspouts, fascia and in primary areas like foundations, frames, roofs; surface cracking, crumbling, potholes, depressions, loose paving material, weeds pro- truding through surface."

-   "**Structures below Minimum Code Standards:** Structures that do not meet the standards of zoning, subdivision, building, fire, and other governmental codes applicable to the property."

-   "**Illegal Use of Individual Structures:** Uses in violation of the applicable federal, state, or local laws."

-   "**Excessive Vacancies:** The presence of buildings that are unoccupied or under-utilized and that represent an adverse influence on the area because of the frequency, extent, or duration of the vacancies."

-   "**Lack of Ventilation, Light or Sanitary Facilities:** Inadequate natural light or ventilation in rooms without windows or improper window sizes; Inadequate sanitary facilities such as garbage storage, bathroom facilities, hot water, etc."

-   "**Inadequate Utilities:** Underground and overhead utilities that are of insufficient capacity, deteriorated, antiquated, obsolete, or in disrepair, or lacking."

-   "**Excessive Land Coverage & Overcrowding:** Over-intensive use of property and the crowding of buildings and accessory facilities on a site."

-   "**Deleterious Land Use or Layout:** Incompatible land-use relationships, inappro- priate mixed uses inside buildings, environ- mentally unsuitable uses, offensive uses, etc."

-   "**Environmental Clean-up:** A need for the clean-up of hazardous waste, hazardous substances, or underground storage tanks required by State or federal law, provided that the remediation costs constitute a material impediment to the development or redevelop- ment of the redevelopment project area"

-   "**Lack of Community Planning:** Absence of the guidance of a community plan or where such a plan has not been followed, resulting in adverse or incompatible land-use relationships, inadequate street layout, im- proper subdivision, parcels of inadequate shape and size to meet contemporary development standards, or other evidence demonstrating an absence of effective community planning."

-   "**Lack of Growth in Equalized Assessed Valuation (EAV):** The total EAV for the study area has either de- clined or is increasing at an annual rate that is less than that of the balance of the municipality for three of the last five calendar years"

For a region to be considered "blighted" it must satisfy at least 5 of these indicator.

Information Source: <https://www.chicago.gov/content/dam/city/depts/dol/rulesandregs/DPD-Community-Development-Rules.pdf>

**What Are The Goals of A Redevelopment Plan:**

-   "**Studies, Surveys, Development of Plans and Specifications, Implementation and Administration of the Redevelopment Plan:** Costs may include staff and professional services for architectural, engineering, development advisors and managers, legal, marketing, financial, planning or other services, and related hard and soft costs."

-   "**Property Assembly:** Costs may include acquisition of land and other property, real or personal, or rights or interest therein, demolition of buildings, clearing and grading of land, and other site preparation costs"

-   "**Rehabilitation, Reconstruction, Repair or Remodeling**"

-   "**Construction of Public Works or Improvements**"

-   "**Job Training and Retraining Projects:** Costs may include welfare-to-work initiatives."

-   "**Financing:** Costs may include necessary and incidental expenses related to the issuance of obligations, including interest accruing during the estimated period of construction of any redevelopment project for which such obligations are issued and for not exceeding 36 months thereafter and including reasonable reserves related thereto"

-   "**All or a Portion of a Taxing District's Capital Costs:** Costs resulting from the redevelopment project necessarily incurred or to be incurred within a taxing district in furtherance of the objectives of the redevelopment plan and project, to the extent the municipality by written agreement accepts and approves such costs."

-   "**Relocation Activities**"

-   "**Payment in Lieu of Taxes**"

-   "**Interest Costs:** Costs may include expenses incurred by a developer or other user related to the construction, renovation or rehabilitation of a redevelopment project, generally up to 30 percent of interest, but up to 75 percent of interest costs incurred for rehabilitated or new housing units for low- and very low-income households"

-   "**Costs of the Construction of Low-Income Housing:** TIF revenues may be used to pay up to 50 percent of the cost of construction of new housing units to be occupied by low- and very low income families."

-   "**Day Care**"

While the scope of TIFs is far to large to fully understand at a complex level, this project aims to see if a small subset of the **redevelopment goals** have been reached. It also aims to see if a subset of the conditions of **blight** have been ameliorated.

**Research Question:**“Do TIFs in Chicago ameliorate blight and promote economic development?”

## Data Exploration and Preparation

### Data Sets \\ Exploration:

#### Community Areas

[https://data.cityofchicago.org/Facilities-Geographic-Boundaries/Boundaries-Community-Areas-Map/cauq-8yn6?](https://data.cityofchicago.org/Facilities-Geographic-Boundaries/Boundaries-Community-Areas-Map/cauq-8yn6?utm_source=chatgpt.com)

Data set that gives an index for Chicago community areas.

#### TIF Data

**TIF Projects**

[https://data.cityofchicago.org/Community-Economic-Development/Tax-Increment-Financing-TIF-Projects-Map/v3a3-hhqn?](https://data.cityofchicago.org/Community-Economic-Development/Tax-Increment-Financing-TIF-Projects-Map/v3a3-hhqn?utm_source=chatgpt.com)

"This dataset is a comprehensive list of every project in every TIF District that has received funding from the City of Chicago via the TIF program from the inception of TIF to current. Public Infrastructure projects are not included in this dataset."

#### Blight Indicators

**Availability of Service Requests**

311 Service Requests - Tree Trims - Historical (environmental blight indicator):

<https://data.cityofchicago.org/Service-Requests/311-Service-Requests-Tree-Trims-Historical/uxic-zsuj/about_data>

"As described in <https://data.cityofchicago.org/stories/s/311-Dataset-Changes-12-11-2018/d7nq-5g7t>, the function of this dataset was replaced by <https://data.cityofchicago.org/d/v6vf-nfxy>. This dataset is historical-only.\
\
All open and completed tree trim requests made to 311 since January 1, 2011. The Department of Streets and Sanitation maintains all trees growing in the public way and performs regular maintenance trimming in response to 311 requests. Crisis trimming is performed on an emergency basis in response to hazardous conditions such as broken or hanging branches. Requests that have been labeled as Duplicates are in the same geographic area and have been entered into 311’s Customer Service Requests (CSR) system at around the same time as a previous request. Duplicate requests are labeled as such in the Status field, as either "Open - Dup" or "Completed - Dup." Data is updated daily."

**Vacant Buildings / Properties**

<https://data.cityofchicago.org/Service-Requests/311-Service-Requests-Vacant-and-Abandoned-Building/d9re-tmpw>

"Data set contains all 311 calls for open and vacant buildings reported to the City of Chicago since January 1, 2010. The information is updated daily with the previous day's calls added to the records. The data set provides the date of the 311 service request and the unique Service Request \# attached to each request. For each request, the following information (as reported by the 311 caller) is available: address location of building; whether building is vacant or occupied; whether the building is open or boarded; entry point if building is open; whether non-residents are occupying or using the building, if the building appears dangerous or hazardous and if the building is vacant due to a fire."

#### Development Indicators

**Business Licenses Issued**

"Business licenses issued by the Department of Business Affairs and Consumer Protection in the City of Chicago from 2002 to the present. This dataset contains a large number of records/rows of data and may not be viewed in full in Microsoft Excel. Therefore, when downloading the file, select CSV from the Export menu. Open the file in an ASCII text editor, such as Notepad or Wordpad, to view and search. "\
\
Data fields requiring description are detailed below.

(CONTAINS A LIST OF NEW DISTRIBUTED BUSINESS LICENSES)

### Data Preparation

The city of Chicago is divided into 77 different community areas with a unique ID number. We need to be able to divide the city into districts on order to know where different data points, vacant buildings, grocery stores, etc. are occurring. We will do this by indexing the community areas by "AREA_NUMBE"(area number) and "COMMUNITY"(community name). The Idea is to determine how many TIFs a particular community has at a particular time and determine as time increases whether or not particular markers get better worse or remain the same.

```{r}
# Install data cleaning packages (only run once)
# install.packages(c("janitor", "dplyr"))
# install.packages("readxl") 

```

**Summary:** Here we load the csv file "Boundaries\_-\_Community_Areas_20251111.csv" into the community_areas data frame. We clean the file an only keep the fields "COMMUNITY" and "AREA_NUMBE" as "area_num_1", and "community" and feed it into community_area_index. This will allow us to index every Chicago community by a number in the interval $[1,77]$, each with a distinct community name.

```{r}
library(janitor); library(dplyr); library(stringr)

# Read in the csv file
community_areas <- read.csv("data/Boundaries_-_Community_Areas_20251111.csv")
# Only keep the fields community "COMMUNITY" and "AREA_NUMBE" as "area_num_1", and "community"
community_area_index <- community_areas |>
                          clean_names() |>
                          select(area_num_1, community)

# Make sure to remove any unwanted spaces from the community area names
community_area_index$community <- str_trim(community_area_index$community)

```

**Summary:** Here we load the csv file into "TIF_projects_original" "Tax_Increment_Financing\_(TIF)\_Funded_RDA_and_IGA_Projects_20251111.csv". This file holds information on most if not all TIFs since 1993. The file has a considerable amount of information, but for our purposes, we will only extract the information that tells us which community area the TIF is given to, and how much money the TIF provided for that community. We also load important libraries for data cleaning and extraction

```{r}
# Load necessary libraries
library(dplyr)
library(tidyr)
library(janitor)
library(readr)
library(lubridate)
# Load file of all TIF projects in Chicago
TIF_projects_original <- read.csv("data/Tax_Increment_Financing_(TIF)_Funded_RDA_and_IGA_Projects_20251111.csv")

```

**Summary:** In this section we take "TIF_projects_original" and strip it of each unnecessary column and feed the new data frame into "TIF_projects". We leave the columns "CDC.DATE" (Community Development Committee Approval Date), "COC.DATE" (Certificate of Completion Date), "APPROVED.AMOUNT" (The TIF subsidy), "TOTAL.PROJECT.COST" (The Total Project Cost), "WARD" (The ward the TIF was given to), and "COMMUNITY.AREA" (The community area the TIF was award to). I keep this data frame for purposes of viewing relatively important data to the project.

```{r}
# Remove the unnecessary columns in the TIF_projects_original data frame
TIF_projects <- TIF_projects_original |>
  select(-ID, -TIF.DISTRICT, -PROJECT.NAME, -PROJECT.DESCRIPTION, 
         -ADDRESS, -TIF.SUBSIDY.PERCENTAGE, -AFFORDABLE.UNITS,
         -X.COORDINATE, -Y.COORDINATE, -LATITUDE, -LONGITUDE,
         -LOCATION, -DEVELOPER)
```

**Summary:** In this section of code we take the "TIF_projects" data frame and create new columns, removing all of the previous ones. We also standardize the naming scheme for each column. In the data frame we now have columns "community_area", "year", and "tif_dollars". We also clean our data set of NA values, empty spaces, and random characters.

```{r}
# Here we will transform TIF_projects into a fully cleaned data frame
TIF_projects <- TIF_projects |>
  transmute(
    # Standardize the community area names, remove extra spaces and capitalize
    community_area = toupper(str_trim(COMMUNITY.AREA)),
    # Get only the year value from the date
    year = year(mdy(CDC.DATE)),
    # Normalize the character for the amount of dollars spent on the TIF and handle NA  characters
    tif_dollars = parse_number(coalesce(
      as.character(TOTAL.PROJECT.COST),
      NA_character_
    ))
  ) |>
  filter(
    # Filter out years not between 1993 and 2023, and remove NA community names
    !is.na(year), year >= 1993, year <= 2023,
    # Filter out rows with NA community names and empty community name string values
    !is.na(community_area), nzchar(community_area),
    # Remove rows that are made purely of digits, spaces, hypehns, and periods
    !stringr::str_detect(community_area, "^[0-9 .-]+$")
  )

```

**Summary:** In this section of code we reorganize our "TIF_projects" data frame. We create pairings of community areas by year. For each of these pairs we determine how many TIFs were awarded to that community in that year and how much total TIF money was awarded to that community in that year. From this we create a new data frame "TIF_by_year" that has columns "year", "community_area", "n_tifs", and "total_tif_dollars". We also create a list of each year from 1993 to 2023 and a list of each community area sorted alphabetically.

```{r}
# Summarize by year & community (with new TIFs and money added that year)
TIF_by_year <- TIF_projects |>
  # Treat each year, community pair as a group
  dplyr::group_by(year, community_area) |>
  # 
  dplyr::summarise(
    # Counts how many TIFs each year, community group has (every row is one TIF project)
    n_tifs = dplyr::n(),
    # Sums the amount of TIF money each community area made each year. na.rm makes sure to treat NA values.
    total_tif_dollars = sum(tif_dollars, na.rm = TRUE),
    .groups = "drop"
  )

# Create a list of numbers from 1993 to 2023
all_years  <- 1993:2023
# Creates a list of all community names sorted alphabetically
all_comms  <- sort(unique(TIF_projects$community_area))


```

**Summary:** This section of code finishes the arrangement the "TIF_by_year" data frame into a list of data frames that can be navigated easily for analysis. We then take "TIF_by_year" and fill in the missing value pairs using the complete() function. Then we replace the NA values in the "n_tifs" and "total_tif_dollars" columns in these new value pairs with 0. We then arrange the data frame with a focus on grouping community names with year in ascending order so that we may find a rolling/cumulative sum of the number of TIFs and total TIF dollars for each year from 1993 to 2023. After this is done, we rearrange the data with a focus on grouping by community with the years in numerical ascending order. Finally, we split the data frame by year to create a list of data frames by community, "TIF_community_list". Each element in this list is a data frame representing a community that displays the TIFs, and TIF money awarded to the community in the years from 1993 to 2023, along with the rolling count and the rolling balance since 1993. **(THIS DATA FRAME MODEL WILL BE USED REPEATEDLY THROUGHOUT THE PROJECT)**

```{r}
TIF_by_year <- TIF_by_year |>
  # Currently TIF_by_year only has year community area pairs where the number of TIFs awarded were greater than or equal to 1. Now we add every other possible year x community pair. These were the years for each community where no TIFs and money were awarded. The rows are created with NA in the n_tifs and total_tif_dollars columns
  tidyr::complete(year = all_years, community_area = all_comms) |>
  dplyr::mutate(
    # Here we replace every NA value for n_tifs in the new year x community pairs with 0
    n_tifs = tidyr::replace_na(n_tifs, 0L),
    # Here we replace every NA value for total_tif_dollars in the new year x community pairs with 0
    total_tif_dollars = tidyr::replace_na(total_tif_dollars, 0)
  ) |>
  # This function rearranges the rows in ascending numerical and alphabetical order so that all of the rows are organized nicely
  dplyr::arrange(community_area, year) |>
  # In order to get a rolling TIF fund we group our data by community area so each group desribes each community for the year from 1993 to 2023
  dplyr::group_by(community_area) |> 
  # We create two new columns rolling_tif_balance and rolling_tif_count. Since the community areas are arranged in order by year in ascending order cumsum(total_tif_dollars) and cumsum(n_tifs) will giving a rolling balance and rolling count respectively for each year.
  dplyr::mutate(rolling_tif_balance = cumsum(total_tif_dollars), rolling_tif_count =  cumsum(n_tifs)) |>
  # Wow we remove the group structure
  dplyr::ungroup() |>
  # With the main part of the data cleaning done, we can now rearrange the data opposite to how we did before. Now we have each year with all of the communities in alphabetical order, then the next year assorted in ascending alphabetical order.
  dplyr::arrange(community_area, year)

# Split into a list of data frames (one per community)
TIF_community_list <- split(TIF_by_year, TIF_by_year$community_area)

```

**Vacant Buildings Data Preparation**

**Summary:** Here we load the vacant buildings csv file "311_Service_Requests\_-*Vacant_and_Abandoned_Buildings_Reported*-\_Historical_20251111.csv" into the data frame "vacant_buildings_original". From this data frame we only keep the columns "Community.Area", and "DATE.SERVICE.REQUEST.WAS.RECEIVED" and feed it into the vacant_buildings data frame. We then rename the "Community.Area" column to "area_num_1" so that we can add a new column "community" that matches the area number to the community area name. Finally, we rename the columns to be "community_area", "year", and "area_num_1" and clean the date to be just the year.

```{r}
# Load CSV file of all vacant buildings in Chicago from 2008 to 2018
vacant_buildings_original <- read.csv("data/311_Service_Requests_-_Vacant_and_Abandoned_Buildings_Reported_-_Historical_20251111.csv")

# Only keep the columns Community.Area and DATE.SERVICE.REQUEST.WAS.REVIEVED
vacant_buildings <- vacant_buildings_original |>
  select(Community.Area, DATE.SERVICE.REQUEST.WAS.RECEIVED)

# Rename Community.Area column so that it is consistent with the community_area_index
colnames(vacant_buildings)[1] <- "area_num_1"

# Map each of the community area numbers with their respective community area name and add a column with this correspondance
vacant_buildings <- vacant_buildings |>
  dplyr::left_join(community_area_index, by = "area_num_1")

# Now we will reorder and rename each column
vacant_buildings <- vacant_buildings |>
  transmute(
    # Rename community to community_area and put it first
    community_area = community,
    # Clean the date leave only the the year that a service request was filed
    year = year(mdy(DATE.SERVICE.REQUEST.WAS.RECEIVED)),
    # Fill in the final column
    area_num_1 = area_num_1
  )
```

**Summary:** Now we will create a new list of data frames that is essentially identical to TIF_community_list but instead the years will only go from 2008 to 2018 and we will incorporate the number of new vacant buildings per year for each community. Before we can do this, we must first count how many vacant buildings there are added per year for each community. This measure count will function to model a rate for vacant houses each year in a particular community. After this code block is finished, "TIF_vacant_buildings_by_year" will function as the data frame that we will create a model for

```{r}
# Here we take vacant_buildings and create a new data frame with the counts of each abandoned building for each community each year
vacant_buildings_by_year <- vacant_buildings |>
  # We group each row by year and community area
  dplyr::group_by(year, community_area) |>
  # The size of each of these groups gives the number of reported vacant buildings that year
  dplyr::summarise(
    n_vacant = dplyr::n(),   # number of reported abandoned buildings
    .groups = "drop"
  )

# We then take the TIF by year data frame and join it with vacant_buildings_by_year
TIF_vacant_buildings_by_year <- TIF_by_year |>
  # We join the number of vacant buildings with each respective community area and year
  dplyr::left_join(
    vacant_buildings_by_year,
    by = c("year", "community_area")
  ) |>
  dplyr::mutate(
    # If a community has no vacant building in a particular year, we change the default NA value to zero
    n_vacant = tidyr::replace_na(n_vacant, 0L)
  )

# Since the vacant buildings data frame only goes from 2008 to 2018, we restrict our data frame to those years.
TIF_vacant_buildings_by_year <- TIF_vacant_buildings_by_year |>
  dplyr::filter(year >= 2008, year <= 2018)

```

**Tree Trim Service Request Data Preparation**

**Summary:** In this section of code we take our file named "311_Service_Requests\_-*Tree_Trims*-\_Historical_20251128.csv"and convert it into a data frame that we then start preparing. First we remove all columns that aren't the columns of interest. We then change the names of the columns and extract only the year value from the dates.

```{r}
# Load CSV file of all tree trim service requests from 1971 to 2018 in Chicago
tt_serv_req_original <- read.csv("data/311_Service_Requests_-_Tree_Trims_-_Historical_20251128.csv")

# Select and use only the columns that are important for our services
tt_serv_req <- tt_serv_req_original |>
  select(Creation.Date, Status, Completion.Date, Community.Area)


# Rename "Community.Area" column so that it is consistent with our TIF data frame
colnames(tt_serv_req)[colnames(tt_serv_req) == "Community.Area"] <- "area_num_1"

# Map each of the community area numbers with their respective community area name and add a column with this correspondance
tt_serv_req <- tt_serv_req |>
  dplyr::left_join(community_area_index, by = "area_num_1")

# Now we will reorder and rename each column
tt_serv_req <- tt_serv_req |>
  transmute(
    # Rename community to community_area and put it first
    community_area = community,
    # Clean the date leave only the the year that a service request was ordered and the date that it was completed
    year_completed = year(mdy(Completion.Date)),
    year_ordered = year(mdy(Creation.Date)),
    # Fill in the final column
    area_num_1 = area_num_1
  )

```

**Summary:** In this block of code we first group tt_serv_req by year_completed and community area and filter out NA values. We then count the number of rows with completion dates and this gives us the number for the amount of completed service requests for each community per year. We feed this new modified data frame into tt_serv_req_completed. We do the same thing for year_ordered and get a data frame that has the number of ordered services requests per year for each community. We feed this data frame into tt_ser_req_ordered.

Next, we merge these data frames into TIF_by_year to create a new data frame "TIF_tt_serv_req_by_year". We also limit this data frame to only contain rows between the years of 2011 and 2018.

```{r}
# Here we create a data frame from tt_serv_req called tt_serv_req_completed that gives us a count of how many service requests were created in that year.
tt_serv_req_completed <- tt_serv_req |>
  dplyr::filter(!is.na(year_completed)) |>  # remove rows with NA year
  # We group each row by year_completed and community area
  dplyr::group_by(year_completed, community_area) |>
  # The size of each of these groups gives the number of service requests completed in that community area that year
  dplyr::summarise(
    n_completed = dplyr::n(),
    .groups = "drop"
  )

# Here we create a data frame from tt_serv_req called tt_serv_req_ordered that gives us a count of how many service requests were ordered in that year.
tt_serv_req_ordered <- tt_serv_req |>
  # We group each row by year_ordered and community area
  dplyr::group_by(year_ordered, community_area) |>
  # The size of each of these groups gives the number of reported service requests ordered in that community area that year
  dplyr::summarise(
    n_ordered = dplyr::n(),   # number of ordered service requests
    .groups = "drop"
  )

# Now we change the name of the year column in each of the data frames to "year" for consistency
colnames(tt_serv_req_completed)[colnames(tt_serv_req_completed) == "year_completed"] <- "year"
colnames(tt_serv_req_ordered)[colnames(tt_serv_req_ordered) == "year_ordered"] <- "year"


TIF_tt_serv_req_by_year <- TIF_by_year |>
  # We join the number of service requests completed with each respective community area and year
  dplyr::left_join(
    tt_serv_req_completed,
    by = c("year", "community_area")
  ) |>
  dplyr::mutate(
    # If a community has no completions in a particular year, we change the default NA value to zero
    n_completed = tidyr::replace_na(n_completed, 0L)
  )

TIF_tt_serv_req_by_year <- TIF_tt_serv_req_by_year |>
  # We join the number of service requests ordered with each respective community area and year
  dplyr::left_join(
    tt_serv_req_ordered,
    by = c("year", "community_area")
  ) |>
  dplyr::mutate(
    # If a community has no orders in a particular year, we change the default NA value to zero
    n_ordered = tidyr::replace_na(n_ordered, 0L)
  )

# Since the tree trim service request data frame only meaningfully goes from 2011 to 2018, we restrict our data frame to those years.
TIF_tt_serv_req_by_year <- TIF_tt_serv_req_by_year |>
  dplyr::filter(year >= 2011, year <= 2018)

```

**New Businesses Data Preparation**

```{r}
# Load CSV file containing information pertaining to issued business licenses
new_businesses_original <- read.csv("data/Business_Licenses_20251129.csv") # Large File

```

**Summary:** Here we first only look at the columns that are important to our purposes "DATE.ISSUED" and "COMMUNITY.AREA". Next we rename "COMMUNITY.AREA" to "area_num_1". Then we remove rows with NA area numbers. Then we map the community area name to each number. Finally we alter the date to only include the year and rearrange the columns

```{r}
# Select and use only the columns that are important for our services
new_businesses <- new_businesses_original |>
  select(DATE.ISSUED, COMMUNITY.AREA)

# Rename "Community.Area" column so that it is consistent with our TIF data frame
colnames(new_businesses)[colnames(new_businesses) == "COMMUNITY.AREA"] <- "area_num_1"

# Remove rows with NA values
new_businesses <- new_businesses %>%
  filter(!is.na(area_num_1))

# Map each of the community area numbers with their respective community area name and add a column with this correspondance
new_businesses <- new_businesses |>
  dplyr::left_join(community_area_index, by = "area_num_1")

# Now we will reorder and rename each column
new_businesses <- new_businesses |>
  transmute(
    # Rename community to community_area and put it first
    community_area = community,
    # Clean the date leave only the year the license was issued
    year = year(mdy(DATE.ISSUED)),
    # Fill in the final column
    area_num_1 = area_num_1
  )

```

**Summary:** First we count every business license issued to every community every year. Then we treat every NA value and replace it with 0 in this new data frame "TIF_new_businesses_by_year". We know this data set goes from 2002 to 2025 and the TIF data frame only goes to 2023, hence we restrict our dataset according to that.

```{r}
# Here we create a data frame from new_businesses called new_businesses_counted that gives us a count of how many business licenses were issued in that year.
new_businesses_by_year <- new_businesses |>
  dplyr::filter(!is.na(year)) |>  # remove rows with NA year
  # We group each row by year and community area
  dplyr::group_by(year, community_area) |>
  # The size of each of these groups gives the number of business licenses issued in that community area that year
  dplyr::summarise(
    n_business_licenses = dplyr::n(),
    .groups = "drop"
  )

new_businesses_by_year <- new_businesses_by_year |>
  dplyr::mutate(
    # If a community has no issued business licenses in a particular year, we change the default NA value to zero
    n_business_licenses = tidyr::replace_na(n_business_licenses, 0L)
  )

TIF_new_businesses_by_year <- TIF_by_year|>
  # We join the number of issued business licenses ordered with each respective community area and year
  dplyr::left_join(
    new_businesses_by_year,
    by = c("year", "community_area")
  )

# Since the issued business license data frame only meaningfully goes from 2003 to 2025, we restrict our data frame to those years. We also have to restrict the upper bound to 2023 since our TIF data frame does not go to 2025
TIF_new_businesses_by_year <- TIF_new_businesses_by_year |>
  dplyr::filter(year >= 2003, year <= 2023)

```

## Model Building

### Goal:

-   **Inference:** Want to quantify relationships between variables. (In this model type we care a lot about model assumptions)

    -   Healthcare

    -   Economics

**\*THIS MODEL IS AN INFERENCE MODEL\***

### Why Use An Inference Model?

There are several reasons why an inference model is the preferred way of answering the question of “Do TIFs in Chicago ameliorate blight and promote economic development?”.

-   In our case, we are not trying to predict the outcome of anything with our model.

-   We are trying to determine whether or not there is any relationship at all between TIFs in Chicago and the state of economic development and the state of blight.

-   In this way, we are attempting to infer a relationship between TIFs and blight/ economic development.

### Model That Will Be Used: Generalized Linear Mixed Effects Model with a Negative Binomial Distribution

A mixed effects model is one that includes both random effects and fixed effects

-   Fixed effects represent parameters that do not vary across different community areas in Chicago.

-   Random effects represent parameters that can vary between different community areas

In our model, each community should be treated differently as none have exactly the same starting conditions. The key reasons why we choose a mixed effects model is because we have multiple sources that vary with starting conditions. For example, the loop may experience different degrees of blight and economic development compared to Englewood.

A many types of generalized linear models are specifically designed to interpret count data; therefore giving the model more explanatory power. Since all of the response variables that I will use are count data, I will use a negative binomial distribution. I also do this to account for overdispersion by incorporating it into the model.

### Basic Model Structure:

We create a random slope mixed effects model. This model will test if communities differ in the the relationship between a given indicator and log TIF spending.

**Random Slope Mixed Effects Model**

$$
\log(\mathbb{E}[I_{cy}|b_{0,c},b_{TIF,c}]) = \beta_0 + b_0,c + (\beta_{TIF}+b_{TIF,c})\log(1+x_{cy})
$$

Where we have

-   $c$ is the index for which community we are working in ($c$ for community)

-   $y$ indexes which observation (year) in our data set we are looking at in our respective community ($y$ for year)

-   $I$ denotes which blight indicator we are looking at, for our model, each of these variables will be a count

-   $\beta_0$ represents the intercept, and $\beta_{TIF}$ represents the slope. These are the fixed effects across all communities.

-   $b_{0c}$ is the random intercept and $b_{TIF,c}$ represents the random slope. These are the random effects for each individual community

-   $x_{cy}$ represents the rolling TIF balance for the community

For each of our data sets, the response is a count variable. Hence, we must use a Generalized Linear Mixed Effects Model for our data. We use a **negative binomial distribution** for our data.

**Transformation:** For the "glmmTMB" model we require that our money data is scaled so that the package can actually work. Hence we scale "rolling_tif_balance" using a log transformation. Not only does this scale the data, but it also removes skews in in the data entries, for example:

$$
\log ($100) - \log ($200) = \log(2) \\
\log($100,000) - \log ($200,000) = \log(2)
$$

This allows areas with more TIF spending to be more balanced with communities with less TIF spending. Furthermore, the log scaling accounts for potential non-linear relationships.

*From this we can define more models:*

**Null Mixed Effects Model:** Our null model will serve as a baseline to test hypotheses. This model only includes the random intercepts and global intercept:

$$
\log(\mathbb{E}[I_{cy}|b_{0c}]) = \beta_0 + b_{0c}
$$

**Fixed Slope Mixed Effects Model:** In this model we choose to only have the random intercept incorporated into our linear regression. This model tests if there is a global correlation between the indicator $I$ and TIF spending.

$$
\log(\mathbb{E}[I_{cy}|b_{0c}]) = \beta_0 + b_{0c} + \beta_{TIF}\log(1+x_{cy})
$$

### Vacant Buildings Model:

This model attempts to see if there is a statistically significant relationship between our log TIF rolling balance (predictor) and the number of vacant buildings (response).

```{r}
library(glmmTMB)

# Scale the data using a log transform so that the function glmmTMB() can run
TIF_vacant_buildings_by_year_scaled <- TIF_vacant_buildings_by_year |>
  dplyr::mutate(
    rolling_tif_balance_sc = log1p(rolling_tif_balance)
  )
```

**Null Mixed Effects Model:** Here we create the null model for hypothesis testing (since $VacantBuildings_{cy}$ is count data we will have to use a generalized linear mixed effects model)

$$
\log(\mathbb{E}[VacantBuildings_{cy}|b_{0c}]) = \beta_0 + b_{0c}
$$

```{r}
null_mod_vacant_buildings <- glmmTMB(
  n_vacant ~ 1 + (1 | community_area),
  data   = TIF_vacant_buildings_by_year_scaled,
  family = nbinom2(link = "log")
)
```

**Fixed Slope Mixed Effects Model:**

$$
\log(\mathbb{E}[VacantBuildings_{cy}|b_{0c}]) = \beta_0 + b_{0c} + \beta_{TIF}\log(1+x_{cy})
$$

```{r}
fixed_slope_mod_vacant_buildings <- glmmTMB(
  n_vacant ~ rolling_tif_balance_sc + (1 | community_area),
  data   = TIF_vacant_buildings_by_year_scaled,
  family = nbinom2(link = "log")
)

# Show the fixed effects
fixef(fixed_slope_mod_vacant_buildings)

# Show the maximum and minimum random effects on intercept
rand_eff_vacant <- ranef(fixed_slope_mod_vacant_buildings)$cond
int_vac <- rand_eff_vacant$community_area[,"(Intercept)"]
min(int_vac)
max(int_vac)
```

**Random Slope Mixed Effects Model**

$$
\log(\mathbb{E}[VacantBuildings_{cy}|b_{0c}, b_{TIF,c}]) = \beta_0 + b_0c + (\beta_{TIF}+b_{TIF,c})\log(1+x_{cy})
$$

```{r}
random_slope_mod_vacant_buildings <- glmmTMB(
  n_vacant ~ rolling_tif_balance_sc + (1 + rolling_tif_balance | community_area),
  data   = TIF_vacant_buildings_by_year_scaled,
  family = nbinom2(link = "log")
)

# Statistically Insignificant Model
```

### Vacant Buildings Model Hypothesis Testing:

Now we will determine if the fixed sloped mixed effects model is a better model than one that just includes the intercept. We will do this using a chi-squared test

-   $H_0: \beta_{TIF} = 0$

-   $H_a: \beta_{TIF} \neq 0$

```{r}
anova(null_mod_vacant_buildings, fixed_slope_mod_vacant_buildings, test = "Chisq")
```

Now we will determine if different slopes per community (random slope mixed effects model) is better at predicting vacant buildings than the fixed slope model

-   $H_0:\text{Var}(b_{TIF,c})=0$

-   $H_a:\text{Var}(b_{TIF,c}) > 0$

```{r}
anova(fixed_slope_mod_vacant_buildings, random_slope_mod_vacant_buildings, test = "Chisq")
```

### Tree Trimming Service Request Completion Model:

This model attempts to see if there is a statistically significant relationship between the number of completed tree trimming service requests in a year in a community (response) and our log TIF rolling balance for each community (predictor).

```{r}

# Scale the data using a log transform so that the function glmmTMB() can run
TIF_tt_serv_req_by_year_scaled <- TIF_tt_serv_req_by_year |>
  dplyr::mutate(
    rolling_tif_balance_sc = log1p(rolling_tif_balance)
  )
```

**Null Mixed Effects Model:** Here we create the null model for hypothesis testing (since $NumberTreesTrimmed_{cy}$ is not count data so we will use a regular linear mixed effects model)

$$
\log(\mathbb{E}[NumberTreesTrimmed_{cy}|b_{0c}]) = \beta_0 + b_{0c}
$$

```{r}
null_mod_tt_serv_req <- glmmTMB(
  n_completed ~ 1 + (1 | community_area),
  data   = TIF_tt_serv_req_by_year_scaled, family = nbinom2(link = "log")
)
```

**Fixed Slope Mixed Effects Model:**

$$
\log(\mathbb{E}[NumberTreesTrimmed_{cy}|b_{0c}]) = \beta_0 + b_{0c} + \beta_{TIF}\log(1+x_{cy})
$$

```{r}
fixed_slope_mod_tt_serv_req <- glmmTMB(
  n_completed ~ rolling_tif_balance_sc + (1 | community_area),
  data   = TIF_tt_serv_req_by_year_scaled, family = nbinom2(link = "log")
)
```

**Random Slope Mixed Effects Model**

$$
\log(\mathbb{E}[NumberTreesTrimmed_{cy}|b_{0c}, b_{TIF,c}]) = \beta_0 + b_{0c} + (\beta_{TIF}+b_{TIF,c})\log(1+x_{cy})
$$

```{r}
random_slope_mod_tt_serv_req <- glmmTMB(
  n_completed ~ rolling_tif_balance_sc + (1 + rolling_tif_balance_sc | community_area),
  data   = TIF_tt_serv_req_by_year_scaled, family = nbinom2(link = "log")
)
# Extract the fixed effects from the model
fixef(random_slope_mod_tt_serv_req)

# Determine the random effects of the model
rand_eff_tt_serv_req <- ranef(random_slope_mod_tt_serv_req)$cond$community_area

# Find the lower bound and upper bound for the intercept
int_tt_serv_req <- rand_eff_tt_serv_req[,"(Intercept)"]
min(int_tt_serv_req)
max(int_tt_serv_req)

# Find the lower bound and the upper bound for the slope
slope_vac <- rand_eff_tt_serv_req[,"rolling_tif_balance_sc"]
min(slope_vac)
max(slope_vac)
```

### Tree Trimming Service Request Completion Model Hypothesis Testing:

Now we will determine if the fixed sloped mixed effects model is a better model than one that just includes the intercept. We will do this using a chi-squared test

-   $H_0: \beta_{TIF} = 0$

-   $H_a: \beta_{TIF} \neq 0$

```{r}
anova(null_mod_tt_serv_req, fixed_slope_mod_tt_serv_req, test = "Chisq")
```

Now we will determine if different slopes per community (random slope mixed effects model) is better at predicting completed tree trimming service requests than the fixed slope model

-   $H_0:\text{Var}(b_{TIF,c})=0$

-   $H_a:\text{Var}(b_{TIF,c}) > 0$

```{r}
anova(fixed_slope_mod_tt_serv_req, random_slope_mod_tt_serv_req, test = "Chisq")
```

### Business Licenses Issued Model:

This model attempts to see if there is a statistically significant relationship between the number of business licenses issued in a year in a community (response) and our log TIF rolling balance (predictor) for each community.

```{r}

# Scale the data using a log transform so that the function glmmTMB() can run
TIF_new_businesses_by_year_scaled <- TIF_new_businesses_by_year |>
  dplyr::mutate(
    rolling_tif_balance_sc = log1p(rolling_tif_balance)
  )
```

**Null Mixed Effects Model:** Here we create the null model for hypothesis testing (since $LicensesIssued_{cy}$ is not count data so we will use a regular linear mixed effects model)

$$
\log(\mathbb{E}[LicensesIssued_{cy}| b_{0c}]) = \beta_0 + b_{0c}
$$

```{r}
null_mod_new_businesses <- glmmTMB(
  n_business_licenses ~ 1 + (1 | community_area),
  data   = TIF_new_businesses_by_year_scaled, family = nbinom2(link = "log")
)
```

**Fixed Slope Mixed Effects Model:**

$$
\log(\mathbb{E}[LicensesIssued_{cy}| b_{0c}]) = \beta_0 + b_{0c} + \beta_{TIF}\log(1+x_{cy})
$$

```{r}
fixed_slope_mod_new_businesses <- glmmTMB(
  n_business_licenses ~ rolling_tif_balance_sc + (1 | community_area),
  data   = TIF_new_businesses_by_year_scaled, family = nbinom2(link = "log")
)

fixef(fixed_slope_mod_new_businesses)
ranef(fixed_slope_mod_new_businesses)
```

**Random Slope Mixed Effects Model**

$$
\log(\mathbb{E}[LicensesIssued_{cy}| b_{0c}, b_{TIF,c}]) = \beta_0 + b_0c + (\beta_{TIF}+b_{TIF,c})\log(1+x_{cy})
$$

```{r}
random_slope_mod_new_businesses <- glmmTMB(
  n_business_licenses ~ rolling_tif_balance_sc + (1 + rolling_tif_balance_sc | community_area),
  data   = TIF_new_businesses_by_year_scaled, family = nbinom2(link = "log")
)

# Extract the fixed effects from the model
fixef(random_slope_mod_new_businesses)

# Determine the random effects of the model
rand_eff_new_businesses <- ranef(random_slope_mod_new_businesses)$cond$community_area

# Find the lower bound and upper bound for the intercept
int_new_businesses <- rand_eff_new_businesses[,"(Intercept)"]
min(int_new_businesses)
max(int_new_businesses)

# Find the lower bound and the upper bound for the slope
slope_bus <- rand_eff_new_businesses[,"rolling_tif_balance_sc"]
min(slope_bus)
max(slope_bus)
```

### Business Licenses Issued Model Hypothesis Testing:

Now we will determine if the fixed sloped mixed effects model is a better model than one that just includes the intercept. We will do this using a chi-squared test

-   $H_0: \beta_{TIF} = 0$

-   $H_a: \beta_{TIF} \neq 0$

```{r}
anova(null_mod_new_businesses, fixed_slope_mod_new_businesses, test = "Chisq")
```

Now we will determine if different slopes per community (random slope mixed effects model) is better at predicting business licenses issued than the fixed slope model

-   $H_0:\text{Var}(b_{TIF,c})=0$

-   $H_a:\text{Var}(b_{TIF,c}) > 0$

```{r}
anova(fixed_slope_mod_new_businesses, random_slope_mod_new_businesses, test = "Chisq")
```
